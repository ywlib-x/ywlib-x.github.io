<!DOCTYPE html>
<html lang="ja">
  <head>
    <title>ywlib-x: ywlib-0/type</title>
    <meta charset=“UFT-8”>
    <meta name="author" content="Yw Ninefold">
    <meta name="viewport" context="width=device-widht, initial-scale=1">
    <link rel="stylesheet" href="ywlib-x.css">
  </head>
  <body>
    <h1>ywlib-0/type.hpp</h1>
    <p>Many template-typenames and template-constants are defined.</p>

    <h2>Typenames</h2>
    <p><code>type::breaker</code> and <code>type::switch_</code> are only defined in <code>&lt;ywlib&gt;</code> in advance.</p>
    <h3>Primal</h3>
    <table border="1"><tr><th>Declaration</th><th>Description</th></tr>
      <tr>
        <td><code>template&lt;bool B_, typename T_ = void&gt; using breaker;</code></td>
        <td>breaks type inference if B_ is false.</td>
      </tr>
      <tr>
        <td><code>template&lt;bool B_, typename T1_, typename T2_&gt; using switch_;</code></td>
        <td>switches two types. The type is T1_ If B_ is true; Otherwise T2_.</td>
      </tr>
      <tr>
        <td><code>using nullptr_t;</code></td>
        <td>equals to <code>decltype(nullptr)</code>, <code>std::nullptr_t</code>.</td>
      </tr>
      <tr>
        <td><code>template&lt;typenames... Ts_&gt; using void_t;</code></td>
        <td>is <code>void</code> if all <code>Ts_...</code> can be type-infered; Otherwise is error-type.</td>
      </tr>
    </table>
    <h3>Add/Remove</h3>
    <table border="1"><tr><th>Declaration</th><th>Description</th></tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_const;</code></td>
        <td>adds <code>const</code> qualifier.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_volatile;</code></td>
        <td>adds <code>volatile</code> qualifier.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_cv;</code></td>
        <td>adds <code>const</code> and <code>volatile</code> qualifier.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_ref_lv;</code></td>
        <td>adds lvalue-reference.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_ref_rv;</code></td>
        <td>adds rvalue-reference.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using add_ptr;</code></td>
        <td>adds pointer.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using remove_const;</code></td>
        <td>removes const qualifier.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; using remove_volatile;</code></td>
        <td>removes volatile qualifier.</td>
      </tr>
      ot2(template&lt;typename T_&gt; using remove_cv;, removes const and volatile qualifier.);
    </table>

    <h2>Functions</h2>
    <p>These are defined in <code>namesapce util</code>.</p>
    <table border="1"><tr><th>Declaration</th><th>Description</th></tr>
      <tr>
        <td><code>inline constexpr bool constevaluating(void)noexcept;</code></td>
        <td>returns true if constevaluated.</td>
      </tr>
      <tr>
        <td><code>template&lt;typename T_&gt; type::add_ref_rv&lt;T_&gt; declval(void)noexcept;</code></td>
        <td>returns any non-evaluable value of the type. (Use in decltype(), noexcept(), etc..)</td>
      </tr>
    </table>
  </body>
</html>
